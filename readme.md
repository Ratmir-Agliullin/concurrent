Пояснения к решениям по задачам:
1. Решение выполнено в тесте CacheTest.java. Есть файл(map.txt), мы из него считываем строки и заполняем ими кэш. В три потока мы считываем значения из кэша и выводим на экран.
Затем, мы явно добавляем новую строку в кэш, проверяем хэш файлы и если он отличается, то очищаем кэш и заново читаем данные из файла в кэш.
Потом выводим размер нового кэша, который должен быть на единицу больше предыдущего.


2. Решение выполнено в тесте SequenceTest.java. Мы создаем два объекта, в один передаем в конструктор ссылку на BigInteger, во второй ссылку на
AtomicReference<BigInteger>. Далее мы создаем по 2 потока для каждого объекта и инкрементируем счетчики по 100 раз(в каждом потоке).
В итоге должно быть, что счетчик в AtomicReference равен 200, а счетчик в BigInteger не равен 200.
Проблемы:
- не работает почему-то инкремент в многопоточке для BigInteger. Отдельно делаю когда инкремент для BigInteger - работает.
инкремент для AtomicReference работает. А для BigInteger - не работает. Может подскажете, где искать ошибку.
- иногда происходит зависание(примерно 1 раз на 10-15 прогонов). Тоже пока не удалось локализовать ошибку.

3. На мой взгляд разешить конфликты нам поможет аннотация qualifier или primary. также можно использовать метод
setAllowBeanDefinitionOverriding в ApplicationContext, но я им не пользовался.


4. Решение выполнено в тесте ScopeBeanTest.java. Мы формируем по два потока для каждого scope бина и передаем ссылки на них в конструкторе.
Далее, мы в каждом потоке увеличивпаем значение внутреннего счетчика бина на 1 по 5 раз. В итоге для prototype бинов значение счетчика=5, т.к. для каждого потока создается
свой бин, а для singleton бина значение счетчка = 10, т.к. создается 1 бин и к нему обращается 2 потока.